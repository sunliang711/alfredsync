{
  "alfredsnippet" : {
    "snippet" : "#!\/bin\/bash\nif [ -z \"${BASH_SOURCE}\" ]; then\n    this=${PWD}\nelse\n    rpath=\"$(readlink ${BASH_SOURCE})\"\n    if [ -z \"$rpath\" ]; then\n        rpath=${BASH_SOURCE}\n    elif echo \"$rpath\" | grep -q '^\/'; then\n        # absolute path\n        echo\n    else\n        # relative path\n        rpath=\"$(dirname ${BASH_SOURCE})\/$rpath\"\n    fi\n    this=\"$(cd $(dirname $rpath) && pwd)\"\nfi\n\nexport PATH=$PATH:\/usr\/local\/sbin:\/usr\/local\/bin:\/usr\/sbin:\/usr\/bin:\/sbin:\/bin\n\nuser=\"${SUDO_USER:-$(whoami)}\"\nhome=\"$(eval echo ~$user)\"\n\n# export TERM=xterm-256color\n\n# Use colors, but only if connected to a terminal, and that terminal\n# supports them.\nif which tput >\/dev\/null 2>&1; then\n    ncolors=$(tput colors 2>\/dev\/null)\nfi\nif [ -t 1 ] && [ -n \"$ncolors\" ] && [ \"$ncolors\" -ge 8 ]; then\n    RED=\"$(tput setaf 1)\"\n    GREEN=\"$(tput setaf 2)\"\n    YELLOW=\"$(tput setaf 3)\"\n    BLUE=\"$(tput setaf 4)\"\n    CYAN=\"$(tput setaf 5)\"\n    BOLD=\"$(tput bold)\"\n    NORMAL=\"$(tput sgr0)\"\nelse\n    RED=\"\"\n    GREEN=\"\"\n    YELLOW=\"\"\n    CYAN=\"\"\n    BLUE=\"\"\n    BOLD=\"\"\n    NORMAL=\"\"\nfi\n\n# error code\nerr_require_root=1\nerr_require_linux=2\nerr_require_command=3\n\n_err() {\n    echo \"$*\" >&2\n}\n\n_command_exists() {\n    command -v \"$1\" >\/dev\/null 2>&1\n}\n\n_require_command() {\n    if ! _command_exists \"$1\"; then\n        echo \"require command $1\" 1>&2\n        exit ${err_require_command}\n    fi\n}\n\nrootID=0\n\n_runAsRoot() {\n    local trace=0\n    local subshell=0\n    local nostdout=0\n    local nostderr=0\n\n    local optNum=0\n    for opt in ${@}; do\n        case \"${opt}\" in\n        --trace | -x)\n            trace=1\n            ((optNum++))\n            ;;\n        --subshell | -s)\n            subshell=1\n            ((optNum++))\n            ;;\n        --no-stdout)\n            nostdout=1\n            ((optNum++))\n            ;;\n        --no-stderr)\n            nostderr=1\n            ((optNum++))\n            ;;\n        *)\n            break\n            ;;\n        esac\n    done\n\n    shift $(($optNum))\n    local cmd=\"${*}\"\n    bash_c='bash -c'\n    if [ \"${EUID}\" -ne \"${rootID}\" ]; then\n        if _command_exists sudo; then\n            bash_c='sudo -E bash -c'\n        elif _command_exists su; then\n            bash_c='su -c'\n        else\n            cat >&2 <<-'EOF'\n\t\t\tError: this installer needs the ability to run commands as root.\n\t\t\tWe are unable to find either \"sudo\" or \"su\" available to make this happen.\n\t\t\tEOF\n            return 1\n        fi\n    fi\n\n    local fullcommand=\"${bash_c} ${cmd}\"\n    if [ $nostdout -eq 1 ]; then\n        cmd=\"${cmd} >\/dev\/null\"\n    fi\n    if [ $nostderr -eq 1 ]; then\n        cmd=\"${cmd} 2>\/dev\/null\"\n    fi\n\n    if [ $subshell -eq 1 ]; then\n        if [ $trace -eq 1 ]; then\n            (\n                { set -x; } 2>\/dev\/null\n                ${bash_c} \"${cmd}\"\n            )\n        else\n            (${bash_c} \"${cmd}\")\n        fi\n    else\n        if [ $trace -eq 1 ]; then\n            { set -x; } 2>\/dev\/null\n            ${bash_c} \"${cmd}\"\n            local ret=$?\n            { set +x; } 2>\/dev\/null\n            return $ret\n        else\n            ${bash_c} \"${cmd}\"\n        fi\n    fi\n}\n\nfunction _insert_path() {\n    if [ -z \"$1\" ]; then\n        return\n    fi\n    echo -e ${PATH\/\/:\/\"\\n\"} | grep -c \"^$1$\" >\/dev\/null 2>&1 || export PATH=$1:$PATH\n}\n\n_run() {\n    local trace=0\n    local subshell=0\n    local nostdout=0\n    local nostderr=0\n\n    local optNum=0\n    for opt in ${@}; do\n        case \"${opt}\" in\n        --trace | -x)\n            trace=1\n            ((optNum++))\n            ;;\n        --subshell | -s)\n            subshell=1\n            ((optNum++))\n            ;;\n        --no-stdout)\n            nostdout=1\n            ((optNum++))\n            ;;\n        --no-stderr)\n            nostderr=1\n            ((optNum++))\n            ;;\n        *)\n            break\n            ;;\n        esac\n    done\n\n    shift $(($optNum))\n    local cmd=\"${*}\"\n    bash_c='bash -c'\n\n    local fullcommand=\"${bash_c} ${cmd}\"\n    if [ $nostdout -eq 1 ]; then\n        cmd=\"${cmd} >\/dev\/null\"\n    fi\n    if [ $nostderr -eq 1 ]; then\n        cmd=\"${cmd} 2>\/dev\/null\"\n    fi\n\n    if [ $subshell -eq 1 ]; then\n        if [ $trace -eq 1 ]; then\n            (\n                { set -x; } 2>\/dev\/null\n                ${bash_c} \"${cmd}\"\n            )\n        else\n            (${bash_c} \"${cmd}\")\n        fi\n    else\n        if [ $trace -eq 1 ]; then\n            { set -x; } 2>\/dev\/null\n            ${bash_c} \"${cmd}\"\n            { local ret=$?; } 2>\/dev\/null\n            { set +x; } 2>\/dev\/null\n            return ${ret}\n        else\n            ${bash_c} \"${cmd}\"\n        fi\n    fi\n}\n\nfunction _ensureDir() {\n    local dirs=$@\n    for dir in ${dirs}; do\n        if [ ! -d ${dir} ]; then\n            mkdir -p ${dir} || {\n                echo \"create $dir failed!\"\n                exit 1\n            }\n        fi\n    done\n}\n\nfunction _root() {\n    if [ ${EUID} -ne ${rootID} ]; then\n        echo \"Require root privilege.\" 1>&2\n        return $err_require_root\n    fi\n}\n\nfunction _require_root() {\n    if ! _root; then\n        exit $err_require_root\n    fi\n}\n\nfunction _linux() {\n    if [ \"$(uname)\" != \"Linux\" ]; then\n        echo \"Require Linux\" 1>&2\n        return $err_require_linux\n    fi\n}\n\nfunction _require_linux() {\n    if ! _linux; then\n        exit $err_require_linux\n    fi\n}\n\nfunction _wait() {\n    # secs=$((5 * 60))\n    secs=${1:?'missing seconds'}\n\n    while [ $secs -gt 0 ]; do\n        echo -ne \"$secs\\033[0K\\r\"\n        sleep 1\n        : $((secs--))\n    done\n    echo -ne \"\\033[0K\\r\"\n}\n\n_must_ok() {\n    if [ $? != 0 ]; then\n        echo \"failed,exit..\"\n        exit $?\n    fi\n}\n\n_info() {\n    echo -n \"$(date +%FT%T) ${1}\"\n}\n\n_infoln() {\n    echo \"$(date +%FT%T) ${1}\"\n}\n\n_error() {\n    echo -n \"$(date +%FT%T) ${RED}${1}${NORMAL}\"\n}\n\n_errorln() {\n    echo \"$(date +%FT%T) ${RED}${1}${NORMAL}\"\n}\n\n_checkService() {\n    _info \"find service ${1}..\"\n    if systemctl --all --no-pager | grep -q \"${1}\"; then\n        echo \"OK\"\n    else\n        echo \"Not found\"\n        return 1\n    fi\n}\n\ned=vi\nif _command_exists vim; then\n    ed=vim\nfi\nif _command_exists nvim; then\n    ed=nvim\nfi\n# use ENV: editor to override\nif [ -n \"${editor}\" ]; then\n    ed=${editor}\nfi\n\n##### begin progress bar #####\n# Usage:\n# Source this script\n# _enable_trapping <- optional to clean up properly if user presses ctrl-c\n# _setup_scroll_area <- create empty progress bar\n# _draw_progress_bar 10 <- advance progress bar\n# _draw_progress_bar 40 <- advance progress bar\n# _block_progress_bar 45 <- turns the progress bar yellow to indicate some action is requested from the user\n# _draw_progress_bar 90 <- advance progress bar\n# _destroy_scroll_area <- remove progress bar\n\n# Constants\nCODE_SAVE_CURSOR=\"\\033[s\"\nCODE_RESTORE_CURSOR=\"\\033[u\"\nCODE_CURSOR_IN_SCROLL_AREA=\"\\033[1A\"\nCOLOR_FG=\"\\e[30m\"\nCOLOR_BG=\"\\e[42m\"\nCOLOR_BG_BLOCKED=\"\\e[43m\"\nRESTORE_FG=\"\\e[39m\"\nRESTORE_BG=\"\\e[49m\"\n\n# Variables\nPROGRESS_BLOCKED=\"false\"\nTRAPPING_ENABLED=\"false\"\nTRAP_SET=\"false\"\n\nCURRENT_NR_LINES=0\n\n_setup_scroll_area() {\n    # If trapping is enabled, we will want to activate it whenever we setup the scroll area and remove it when we break the scroll area\n    if [ \"$TRAPPING_ENABLED\" = \"true\" ]; then\n        _trap_on_interrupt\n    fi\n\n    lines=$(tput lines)\n    CURRENT_NR_LINES=$lines\n    let lines=$lines-1\n    # Scroll down a bit to avoid visual glitch when the screen area shrinks by one row\n    echo -en \"\\n\"\n\n    # Save cursor\n    echo -en \"$CODE_SAVE_CURSOR\"\n    # Set scroll region (this will place the cursor in the top left)\n    echo -en \"\\033[0;${lines}r\"\n\n    # Restore cursor but ensure its inside the scrolling area\n    echo -en \"$CODE_RESTORE_CURSOR\"\n    echo -en \"$CODE_CURSOR_IN_SCROLL_AREA\"\n\n    # Start empty progress bar\n    _draw_progress_bar 0\n}\n\n_destroy_scroll_area() {\n    lines=$(tput lines)\n    # Save cursor\n    echo -en \"$CODE_SAVE_CURSOR\"\n    # Set scroll region (this will place the cursor in the top left)\n    echo -en \"\\033[0;${lines}r\"\n\n    # Restore cursor but ensure its inside the scrolling area\n    echo -en \"$CODE_RESTORE_CURSOR\"\n    echo -en \"$CODE_CURSOR_IN_SCROLL_AREA\"\n\n    # We are done so clear the scroll bar\n    _clear_progress_bar\n\n    # Scroll down a bit to avoid visual glitch when the screen area grows by one row\n    echo -en \"\\n\\n\"\n\n    # Once the scroll area is cleared, we want to remove any trap previously set. Otherwise, ctrl+c will exit our shell\n    if [ \"$TRAP_SET\" = \"true\" ]; then\n        trap - INT\n    fi\n}\n\n_draw_progress_bar() {\n    sleep .1\n    percentage=$1\n    lines=$(tput lines)\n    let lines=$lines\n\n    # Check if the window has been resized. If so, reset the scroll area\n    if [ \"$lines\" -ne \"$CURRENT_NR_LINES\" ]; then\n        _setup_scroll_area\n    fi\n\n    # Save cursor\n    echo -en \"$CODE_SAVE_CURSOR\"\n\n    # Move cursor position to last row\n    echo -en \"\\033[${lines};0f\"\n\n    # Clear progress bar\n    tput el\n\n    # Draw progress bar\n    PROGRESS_BLOCKED=\"false\"\n    _print_bar_text $percentage\n\n    # Restore cursor position\n    echo -en \"$CODE_RESTORE_CURSOR\"\n}\n\n_block_progress_bar() {\n    percentage=$1\n    lines=$(tput lines)\n    let lines=$lines\n    # Save cursor\n    echo -en \"$CODE_SAVE_CURSOR\"\n\n    # Move cursor position to last row\n    echo -en \"\\033[${lines};0f\"\n\n    # Clear progress bar\n    tput el\n\n    # Draw progress bar\n    PROGRESS_BLOCKED=\"true\"\n    _print_bar_text $percentage\n\n    # Restore cursor position\n    echo -en \"$CODE_RESTORE_CURSOR\"\n}\n\n_clear_progress_bar() {\n    lines=$(tput lines)\n    let lines=$lines\n    # Save cursor\n    echo -en \"$CODE_SAVE_CURSOR\"\n\n    # Move cursor position to last row\n    echo -en \"\\033[${lines};0f\"\n\n    # clear progress bar\n    tput el\n\n    # Restore cursor position\n    echo -en \"$CODE_RESTORE_CURSOR\"\n}\n\n_print_bar_text() {\n    local percentage=$1\n    local cols=$(tput cols)\n    let bar_size=$cols-17\n\n    local color=\"${COLOR_FG}${COLOR_BG}\"\n    if [ \"$PROGRESS_BLOCKED\" = \"true\" ]; then\n        color=\"${COLOR_FG}${COLOR_BG_BLOCKED}\"\n    fi\n\n    # Prepare progress bar\n    let complete_size=($bar_size * $percentage)\/100\n    let remainder_size=$bar_size-$complete_size\n    progress_bar=$(\n        echo -ne \"[\"\n        echo -en \"${color}\"\n        _printf_new \"#\" $complete_size\n        echo -en \"${RESTORE_FG}${RESTORE_BG}\"\n        _printf_new \".\" $remainder_size\n        echo -ne \"]\"\n    )\n\n    # Print progress bar\n    echo -ne \" Progress ${percentage}% ${progress_bar}\"\n}\n\n_enable_trapping() {\n    TRAPPING_ENABLED=\"true\"\n}\n\n_trap_on_interrupt() {\n    # If this function is called, we setup an interrupt handler to cleanup the progress bar\n    TRAP_SET=\"true\"\n    trap _cleanup_on_interrupt INT\n}\n\n_cleanup_on_interrupt() {\n    _destroy_scroll_area\n    exit\n}\n\n_printf_new() {\n    str=$1\n    num=$2\n    v=$(printf \"%-${num}s\" \"$str\")\n    echo -ne \"${v\/\/ \/$str}\"\n}\n\n##### end progress bar #####\n\n# vim: set ft=sh:\n\n# available VARs: user, home, rootID\n# available functions:\n#    _err(): print \"$*\" to stderror\n#    _command_exists(): check command \"$1\" existence\n#    _require_command(): exit when command \"$1\" not exist\n#    _runAsRoot():\n#                  -x (trace)\n#                  -s (run in subshell)\n#                  --nostdout (discard stdout)\n#                  --nostderr (discard stderr)\n#    _insert_path(): insert \"$1\" to PATH\n#    _run():\n#                  -x (trace)\n#                  -s (run in subshell)\n#                  --no-stdout (discard stdout)\n#                  --no-stderr (discard stderr)\n#    _ensureDir(): mkdir if $@ not exist\n#    _root(): check if it is run as root\n#    _require_root(): exit when not run as root\n#    _linux(): check if it is on Linux\n#    _require_linux(): exit when not on Linux\n#    _wait(): wait $i seconds in script\n#    _must_ok(): exit when $? not zero\n#    _info(): info log\n#    _infoln(): info log with \\n\n#    _error(): error log\n#    _errorln(): error log with \\n\n#    _checkService(): check $1 exist in systemd",
    "uid" : "BAFD4B60-C867-40F3-ADC2-3EC318E399DD",
    "name" : "shellHeader",
    "keyword" : "shell header"
  }
}